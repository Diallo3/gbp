// Avoid `console` errors in browsers that lack a console.
(function() {
    var method;
    var noop = function () {};
    var methods = [
        'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
        'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
        'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
        'timeStamp', 'trace', 'warn'
    ];
    var length = methods.length;
    var console = (window.console = window.console || {});

    while (length--) {
        method = methods[length];

        // Only stub undefined methods.
        if (!console[method]) {
            console[method] = noop;
        }
    }
}());

// Place any jQuery/helper plugins in here.
// Generated by CoffeeScript 1.6.2
// 

/*!
* jquery.counterup.js 1.0
*
* Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
* Released under the GPL v2 License
*
* Date: Nov 26, 2013
*/
(function( $ ){
  "use strict";

  $.fn.counterUp = function( options ) {

    // Defaults
    var settings = $.extend({
        'time': 400,
        'delay': 10
    }, options);

    return this.each(function(){

        // Store the object
        var $this = $(this);
        var $settings = settings;

        var counterUpper = function() {
            var nums = [];
            var divisions = $settings.time / $settings.delay;
            var num = $this.text();
            var isComma = /[0-9]+,[0-9]+/.test(num);
            num = num.replace(/,/g, '');
            var isInt = /^[0-9]+$/.test(num);
            var isFloat = /^[0-9]+\.[0-9]+$/.test(num);
            var decimalPlaces = isFloat ? (num.split('.')[1] || []).length : 0;

            // Generate list of incremental numbers to display
            for (var i = divisions; i >= 1; i--) {

                // Preserve as int if input was int
                var newNum = parseInt(num / divisions * i);

                // Preserve float if input was float
                if (isFloat) {
                    newNum = parseFloat(num / divisions * i).toFixed(decimalPlaces);
                }

                // Preserve commas if input had commas
                if (isComma) {
                    while (/(\d+)(\d{3})/.test(newNum.toString())) {
                        newNum = newNum.toString().replace(/(\d+)(\d{3})/, '$1'+','+'$2');
                    }
                }

                nums.unshift(newNum);
            }

            $this.data('counterup-nums', nums);
            $this.text('0');

            // Updates the number until we're done
            var f = function() {
                $this.text($this.data('counterup-nums').shift());
                if ($this.data('counterup-nums').length) {
                    setTimeout($this.data('counterup-func'), $settings.delay);
                } else {
                    delete $this.data('counterup-nums');
                    $this.data('counterup-nums', null);
                    $this.data('counterup-func', null);
                }
            };
            $this.data('counterup-func', f);

            // Start the count up
            setTimeout($this.data('counterup-func'), $settings.delay);
        };

        // Perform counts when the element gets into view
        $this.waypoint(counterUpper, { offset: '100%', triggerOnce: true });
    });

  };

})( jQuery );

/*
 * jQuery Plugin Development v1.0
 * 
 * Copyright 2013, DotDesign
 * Website: www.dotdesign.in
 * Email: info@dotdesign.in, dotdesign.in@gmail.com
 *  
 * v1.0.0 - Started on 27th March 2013
 * First release
 */

(function($) {

    var ShowInPlaceHolder = function(element, options){
        var self = this;
        self.$el = $(element);
        
        //Defaults options      
        self.options = $.extend({}, $.fn.showInPlaceHolder.defaults, options);
        
        return self;
    };
    
    ShowInPlaceHolder.prototype = {
        init: function(options) {
            var self = this;
            
            // Initialize rendering of DOM
            self.render();
        },
        render: function() {
            var self = this;

            // Binding events
            self.events();
        },
        events: function() {
            var self = this;

            // Click & Mouseover event
            if(self.options.eventType.toLowerCase() == 'click'){
                self.$el.on('click', function(e){
                    self.fillInPlaceHolder();
                    e.preventDefault();
                });
            } else {
                self.$el.on('mouseenter', function(){
                    self.fillInPlaceHolder();
                });
            }
        },
        fillInPlaceHolder: function() {
            var self = this,
                phId = self.options.placeHolderId,
                $phIdEl = $('#'+phId);
            
            $phIdEl.css({
                position: 'relative',
                overflow: 'hidden'
            });

            // Build markup for adding image to placeholder
            if($('.loading',$phIdEl).length === 0){
                $phIdEl.append('<div class="loading" style="position: absolute; left:0; top:0; width:'+ $phIdEl.outerWidth(true) +'px; height:'+ $phIdEl.outerHeight(true) +'px"></div>');
                $phIdEl.append('<div id="'+ phId +'-img-pre-load" class="img-pre-load-box"><img src="'+ self.$el.data('img-src') +'"></div>');
                $('#'+phId+'-img-pre-load img').load(function(){
                    self.preLoadImg();
                });
            }
        },
        preLoadImg: function() {
            var self = this,
                $phImg,
                imgResizeW,
                imgResizeH,            
                phId = self.options.placeHolderId,
                imgTransition = self.options.imgTransition.toLowerCase(),
                fitToPlaceholderVal = self.options.fitToPlaceHolder,
                $phIdEl = $('#'+phId),
                phIdElW = $phIdEl.outerWidth(true),
                phIdElH = $phIdEl.outerHeight(true),
                aniDurationVal = self.options.aniDuration;

            $(this).parent().remove();
            
            $phIdEl.html('');
            $phIdEl.append('<div class="ph-img-box"><img src="'+self.$el.data('img-src')+'" class="ph-img" /></div>');
            

            if(fitToPlaceholderVal){
                self.resizeImg($phIdEl);
            }

            $phImg = $('.ph-img-box', $phIdEl);
            $phImg.css({
                position: 'absolute'
            });
            
            imgResizeW = $phImg.outerWidth(true);
            imgResizeH = $phImg.outerHeight(true);            

            
            // Adding content to image box
            if(typeof self.$el.data('content-id') !== 'undefined' && self.$el.data('content-id') !== ''){
                phImgContent = $('#'+self.$el.data('content-id')).html();
            } else if(typeof self.$el.data('content') !== 'undefined' && self.$el.data('content') !== ''){
                phImgContent = self.$el.data('content');
            } else if(self.options.content !== ''){
                phImgContent = self.options.content;
            } else {
                phImgContent = '';
            }

            // Setting image box height equal to image height
            $('.ph-img-box', $phIdEl).css({
                height: $('.ph-img', $phIdEl).height()
            });
            
            if(phImgContent !== '') {
                $('.ph-img-box', $phIdEl).append('<div class="ph-img-content">' + phImgContent + '</div>');

                $('.ph-img-content', $phIdEl).css({
                    position: 'absolute',
                    zIndex: 2
                });
            } else {
                $('.ph-img-content', $phIdEl).remove();
            }

            // Imagebox animation type
            if(imgTransition == 'fade'){
                $phImg.css('opacity', '0');
                $phImg.animate({
                    opacity: 1
                });
            } else if(imgTransition == 'flyleft'){
                $phImg.css({
                    left: -(phIdElW),
                    top: 0
                });
                $phImg.animate({
                    left: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'flyright'){
                $phImg.css({
                    right: -(phIdElW),
                    top: 0
                });
                $phImg.animate({
                    right: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'flytop'){
                $phImg.css({
                    left: 0,
                    top: -(phIdElW)
                });
                $phImg.animate({
                    left: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'flybottom'){
                $phImg.css({
                    left: 0,
                    bottom: -(phIdElH)
                });
                $phImg.animate({
                    left: 0,
                    bottom: phIdElH - imgResizeH
                }, aniDurationVal);
            } else if(imgTransition == 'flylefttop'){
                $phImg.css({
                    left: -(phIdElW),
                    top: -(phIdElH)
                });
                $phImg.animate({
                    left: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'flyrighttop'){
                $phImg.css({
                    right: -(phIdElW),
                    top: -(phIdElH)
                });
                $phImg.animate({
                    right: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'flyleftbottom'){
                $phImg.css({
                    left: -(phIdElW),
                    bottom: -(phIdElH)
                });
                $phImg.animate({
                    left: 0,
                    bottom: phIdElH - imgResizeH
                }, aniDurationVal);
            } else if(imgTransition == 'flyrightbottom'){
                $phImg.css({
                    right: -(phIdElW),
                    bottom: -(phIdElH)
                });
                $phImg.animate({
                    right: 0,
                    bottom: phIdElH - imgResizeH
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromlefttop'){
                $phImg.css({
                    width: 0,
                    height: 0,
                    left: 0,
                    top: 0
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    left: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromrighttop'){
                $phImg.css({
                    width: 0,
                    height: 0,
                    right: 0,
                    top: 0
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    right: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcenter'){
                $phImg.css({
                    width: 0,
                    height: 0,
                    left: phIdElW / 2,
                    top: phIdElH / 2
                }, aniDurationVal);
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    left: 0,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromleftbottom'){
                $phImg.css({
                    width: 0,
                    height: 0,
                    left: 0,
                    bottom: 0
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    left: 0,
                    bottom: phIdElH - imgResizeH
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromrightbottom'){
                $phImg.css({
                    width: 0,
                    height: 0,
                    right: 0,
                    bottom: 0
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    right: 0,
                    bottom: phIdElH - imgResizeH
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcentertop'){
                $phImg.css({
                    width: 0,
                    height: imgResizeH,
                    top: -(phIdElH / 2),
                    left: phIdElW / 2
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    top:0,
                    left: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcenterleft'){
                $phImg.css({
                    width: imgResizeW,
                    height: 0,
                    top: phIdElH / 2,
                    left: -(phIdElW / 2)
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    top:0,
                    left: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcenterright'){
                $phImg.css({
                    width: imgResizeW,
                    height: 0,
                    top: phIdElH / 2,
                    right: -(phIdElW / 2)
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    top:0,
                    right: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcenterbottom'){
                $phImg.css({
                    width: 0,
                    height: imgResizeH,
                    top: phIdElH / 2,
                    left: phIdElW / 2
                });
                $phImg.animate({
                    width: imgResizeW,
                    height: imgResizeH,
                    top: 0,
                    left: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcenterheight'){
                $phImg.css({
                    height: 0,
                    top: phIdElH / 2
                });
                $phImg.animate({
                    height: imgResizeH,
                    top: 0
                }, aniDurationVal);
            } else if(imgTransition == 'evolvefromcenterwidth'){
                $phImg.css({
                    width: 0,
                    top: 0,
                    left: phIdElW / 2
                });
                $phImg.animate({
                    width: imgResizeW,
                    left: 0
                }, aniDurationVal);
            }
            
            $phIdEl.removeClass('loading');
        },
        resizeImg: function(el){
            var self = this,
                $el = $(el),
                containerW = $el.width(),
                containerH = $el.height(),
                imgW=$('img', $el).width(),
                imgH=$('img', $el).height(),
                newImgW,
                newImgH,                    
                newImgX,
                newImgY,                    
                maxSize;
            
            if ((imgW > containerW) || (imgH > containerH)) {
                
                if (imgW > containerW) {
            
                    maxSize = containerW;                   
                    
                    newImgW = containerW;
                    newImgH = Math.ceil(imgH / imgW * maxSize);
                    
                    if (newImgH > containerH) {
                        maxSize = containerH;
                    
                        newImgH = containerH;
                        newImgW = Math.ceil(imgW / imgH * maxSize);
                    }
                    
                } else {
                    
                    maxSize = containerH;
                    
                    newImgH = containerH;
                    newImgW = Math.ceil(imgW / imgH * maxSize);
                    
                    if (newImgW > containerW) {
                        maxSize = containerW;                  
                    
                        newImgW = containerW;
                        newImgH = Math.ceil(imgH / imgW * maxSize);
                    }
                    
                }
                
            } else {
                newImgW = imgW;
                newImgH = imgH;
            }
            
            
            newImgX = (containerW - newImgW) / 2;
            newImgY = (containerH - newImgH) / 2;
            
            $('img', $el).css({width: newImgW, height: newImgH});
        }
    };
    
    $.fn.showInPlaceHolder = function(options) {
        return this.each(function(key, value){
            var element = $(this);

            // Pass options to plugin constructor
            var showInPlaceHolder = new ShowInPlaceHolder(this, options);
            showInPlaceHolder.init(options);
            
            // Store plugin object in this element's data
            element.data('showInPlaceHolder', showInPlaceHolder);           
        });
    };

    //Default settings
    $.fn.showInPlaceHolder.defaults = {
        content: '',
        eventType: 'hover',                       // hover/click
        placeHolderId: 'placeholder-box',         // Place holder id
        fitToPlaceHolder: true,                   // Fit image in placeholder box
        imgTransition: 'fade',                    // Image transition - none, fade, slideLeft, slideRight, slideTop, slideBottom
        aniDuration: 500                          // Animation duration
    };

    $.fn._reverse = [].reverse;

})(jQuery);

// Enquire JS
/*!
 * enquire.js v2.1.2 - Awesome Media Queries in JavaScript
 * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/enquire.js
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

;(function (name, context, factory) {
    var matchMedia = window.matchMedia;

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory(matchMedia);
    }
    else if (typeof define === 'function' && define.amd) {
        define(function() {
            return (context[name] = factory(matchMedia));
        });
    }
    else {
        context[name] = factory(matchMedia);
    }
}('enquire', this, function (matchMedia) {

    'use strict';

    /*jshint unused:false */
    /**
     * Helper function for iterating over a collection
     *
     * @param collection
     * @param fn
     */
    function each(collection, fn) {
        var i      = 0,
            length = collection.length,
            cont;

        for(i; i < length; i++) {
            cont = fn(collection[i], i);
            if(cont === false) {
                break; //allow early exit
            }
        }
    }

    /**
     * Helper function for determining whether target object is an array
     *
     * @param target the object under test
     * @return {Boolean} true if array, false otherwise
     */
    function isArray(target) {
        return Object.prototype.toString.apply(target) === '[object Array]';
    }

    /**
     * Helper function for determining whether target object is a function
     *
     * @param target the object under test
     * @return {Boolean} true if function, false otherwise
     */
    function isFunction(target) {
        return typeof target === 'function';
    }

    /**
     * Delegate to handle a media query being matched and unmatched.
     *
     * @param {object} options
     * @param {function} options.match callback for when the media query is matched
     * @param {function} [options.unmatch] callback for when the media query is unmatched
     * @param {function} [options.setup] one-time callback triggered the first time a query is matched
     * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
     * @constructor
     */
    function QueryHandler(options) {
        this.options = options;
        !options.deferSetup && this.setup();
    }
    QueryHandler.prototype = {

        /**
         * coordinates setup of the handler
         *
         * @function
         */
        setup : function() {
            if(this.options.setup) {
                this.options.setup();
            }
            this.initialised = true;
        },

        /**
         * coordinates setup and triggering of the handler
         *
         * @function
         */
        on : function() {
            !this.initialised && this.setup();
            this.options.match && this.options.match();
        },

        /**
         * coordinates the unmatch event for the handler
         *
         * @function
         */
        off : function() {
            this.options.unmatch && this.options.unmatch();
        },

        /**
         * called when a handler is to be destroyed.
         * delegates to the destroy or unmatch callbacks, depending on availability.
         *
         * @function
         */
        destroy : function() {
            this.options.destroy ? this.options.destroy() : this.off();
        },

        /**
         * determines equality by reference.
         * if object is supplied compare options, if function, compare match callback
         *
         * @function
         * @param {object || function} [target] the target for comparison
         */
        equals : function(target) {
            return this.options === target || this.options.match === target;
        }

    };
    /**
     * Represents a single media query, manages it's state and registered handlers for this query
     *
     * @constructor
     * @param {string} query the media query string
     * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
     */
    function MediaQuery(query, isUnconditional) {
        this.query = query;
        this.isUnconditional = isUnconditional;
        this.handlers = [];
        this.mql = matchMedia(query);

        var self = this;
        this.listener = function(mql) {
            self.mql = mql;
            self.assess();
        };
        this.mql.addListener(this.listener);
    }
    MediaQuery.prototype = {

        /**
         * add a handler for this query, triggering if already active
         *
         * @param {object} handler
         * @param {function} handler.match callback for when query is activated
         * @param {function} [handler.unmatch] callback for when query is deactivated
         * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
         * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
         */
        addHandler : function(handler) {
            var qh = new QueryHandler(handler);
            this.handlers.push(qh);

            this.matches() && qh.on();
        },

        /**
         * removes the given handler from the collection, and calls it's destroy methods
         * 
         * @param {object || function} handler the handler to remove
         */
        removeHandler : function(handler) {
            var handlers = this.handlers;
            each(handlers, function(h, i) {
                if(h.equals(handler)) {
                    h.destroy();
                    return !handlers.splice(i,1); //remove from array and exit each early
                }
            });
        },

        /**
         * Determine whether the media query should be considered a match
         * 
         * @return {Boolean} true if media query can be considered a match, false otherwise
         */
        matches : function() {
            return this.mql.matches || this.isUnconditional;
        },

        /**
         * Clears all handlers and unbinds events
         */
        clear : function() {
            each(this.handlers, function(handler) {
                handler.destroy();
            });
            this.mql.removeListener(this.listener);
            this.handlers.length = 0; //clear array
        },

        /*
         * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
         */
        assess : function() {
            var action = this.matches() ? 'on' : 'off';

            each(this.handlers, function(handler) {
                handler[action]();
            });
        }
    };
    /**
     * Allows for registration of query handlers.
     * Manages the query handler's state and is responsible for wiring up browser events
     *
     * @constructor
     */
    function MediaQueryDispatch () {
        if(!matchMedia) {
            throw new Error('matchMedia not present, legacy browsers require a polyfill');
        }

        this.queries = {};
        this.browserIsIncapable = !matchMedia('only all').matches;
    }

    MediaQueryDispatch.prototype = {

        /**
         * Registers a handler for the given media query
         *
         * @param {string} q the media query
         * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
         * @param {function} options.match fired when query matched
         * @param {function} [options.unmatch] fired when a query is no longer matched
         * @param {function} [options.setup] fired when handler first triggered
         * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
         * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
         */
        register : function(q, options, shouldDegrade) {
            var queries         = this.queries,
                isUnconditional = shouldDegrade && this.browserIsIncapable;

            if(!queries[q]) {
                queries[q] = new MediaQuery(q, isUnconditional);
            }

            //normalise to object in an array
            if(isFunction(options)) {
                options = { match : options };
            }
            if(!isArray(options)) {
                options = [options];
            }
            each(options, function(handler) {
                if (isFunction(handler)) {
                    handler = { match : handler };
                }
                queries[q].addHandler(handler);
            });

            return this;
        },

        /**
         * unregisters a query and all it's handlers, or a specific handler for a query
         *
         * @param {string} q the media query to target
         * @param {object || function} [handler] specific handler to unregister
         */
        unregister : function(q, handler) {
            var query = this.queries[q];

            if(query) {
                if(handler) {
                    query.removeHandler(handler);
                }
                else {
                    query.clear();
                    delete this.queries[q];
                }
            }

            return this;
        }
    };

    return new MediaQueryDispatch();

}));
